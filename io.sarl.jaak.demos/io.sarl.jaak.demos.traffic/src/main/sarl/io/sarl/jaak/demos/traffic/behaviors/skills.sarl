package io.sarl.jaak.demos.traffic.behaviors

import io.sarl.jaak.demos.traffic.environment.Astar
import io.sarl.jaak.demos.traffic.environment.GroundType
import io.sarl.jaak.demos.traffic.environment.MapUtil
import io.sarl.jaak.demos.traffic.environment.Path
import io.sarl.jaak.demos.traffic.environment.TrafficLight
import io.sarl.jaak.demos.traffic.environment.TrafficLightState
import io.sarl.jaak.environment.body.TurtleObject
import io.sarl.jaak.environment.perception.Perceivable
import java.io.Serializable
import java.util.Map
import java.util.Random
import org.arakhne.afc.math.discrete.object2d.Point2i
import org.arakhne.afc.math.discrete.object2d.Vector2i

/** The skill for driving like a roadhog.
 * 
 * @author $Author: sgalland$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 */
skill RoadhogDrivingSkill implements DrivingCapacity {
	
	var random = new Random
	
	def driveRandomly(
		position : Point2i,
		orientation : Vector2i,
	 	previousOrientation : Vector2i,
		perception : Iterable<? extends Perceivable>,
		ground : Map<Vector2i, Serializable>) : Vector2i {
		
		var directions = MapUtil::detectDirections(position, orientation, previousOrientation, ground)
		
		var motion : Vector2i = null
		
		switch (directions.size) {
			case 0: {
			}
			case 1: {
				motion = directions.get(0)
			}
			default: {
				var n = random.nextInt(directions.size)
				motion = directions.get(n)
			}
		}
		
		if (motion !== null && motion.lengthSquared == 0) {
			motion = null;
		}

		return motion
	}
	
	def followPath(
		path : Path,
		position : Point2i,
		orientation : Vector2i,
		previousOrientation : Vector2i,
		perception : Iterable<? extends Perceivable>,
		ground : Map<Vector2i, Serializable>) : Vector2i {
		if (position.distanceL1(path.get(0)) > 1) {
			return null
		}

		var expectedDirection = new Vector2i
		expectedDirection.sub(path.get(0), position)
		
		return expectedDirection;
	}
	
	def isVehicleStop(body : TurtleObject) : boolean {
		return false
	}
	
	def isStopOnSiren(sirenPosition : Point2i, groundType : Serializable, position : Point2i, direction : Vector2i) : boolean {
		return false
	}
	
}

/** The skill for driving and only considering the roads and the traffic lights.
 * 
 * @author $Author: sgalland$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 */
skill BasicDrivingSkill implements DrivingCapacity {
	
	var random = new Random
	
	def driveRandomly(
		position : Point2i,
		orientation : Vector2i,
	 	previousOrientation : Vector2i,
		perception : Iterable<? extends Perceivable>,
		ground : Map<Vector2i, Serializable>) : Vector2i {
		
		var directions = MapUtil::detectDirections(position, orientation, previousOrientation, ground)
		
		var motion : Vector2i = null
		
		switch (directions.size) {
			case 0: {
			}
			case 1: {
				motion = directions.get(0)
			}
			default: {
				var n = random.nextInt(directions.size)
				motion = directions.get(n)
			}
		}
		
		if (motion !== null && motion.lengthSquared == 0) {
			motion = null;
		}

		return motion
	}
	
	def followPath(
		path : Path,
		position : Point2i,
		orientation : Vector2i,
		previousOrientation : Vector2i,
		perception : Iterable<? extends Perceivable>,
		ground : Map<Vector2i, Serializable>) : Vector2i {
		if (position.distanceL1(path.get(0)) > 1) {
			return null
		}

		var expectedDirection = new Vector2i
		expectedDirection.sub(path.get(0), position)
		
		return expectedDirection;
	}
	
	def isVehicleStop(body : TurtleObject) : boolean {
		var direction = Vector2i::toOrientationVector(body.headingAngle)
		for (trafficLight : body.getPerception(typeof(TrafficLight))) {
			if ((fromTo(body.position, trafficLight.position) == direction)
				&& (trafficLight.state !== TrafficLightState::PASSAGE_ALLOWED)) {
				return true
			}
		}
		return false
	}

	def fromTo(from : Point2i, to : Point2i) : Vector2i {
		var v = new Vector2i
		v.sub(to, from)
		return v;
	}
	
	def isStopOnSiren(sirenPosition : Point2i, groundType : Serializable, position : Point2i, direction : Vector2i) : boolean {
		return false
	}
	
}

/** The skill for driving.
 * 
 * @author $Author: sgalland$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 */
skill StandardDrivingSkill extends BasicDrivingSkill {
	
	def isStopOnSiren(sirenPosition : Point2i, groundType : Serializable, position : Point2i, direction : Vector2i) : boolean {
		// Do not stop on cross road.
		if (groundType !== GroundType::CROSS_ROAD) {
			var sirenDirection = new Vector2i
			sirenDirection.sub(sirenPosition, position)
			var dot = direction.dot(sirenDirection)
			if (dot >= 0) {
				return true
			}
		}
		return false
	}
	
}

skill GPSSkill implements GPSCapacity {

	def findPath(from : Point2i, to : Point2i, vehicleDirection : Vector2i, avoidableRoads : Path = null) : Path {
		return Astar::find(from, to, vehicleDirection, avoidableRoads)
	}
	
	def updatePath(path : Path, from : Point2i, to : Point2i, vehicleDirection : Vector2i) : Path {
		var retPath = path
		if (retPath === null) {
			// Ensure a path is available
			retPath = findPath(from, to, vehicleDirection)
		}
		
		// Update the path for removing the current position
		if (retPath !== null) {
			retPath.removePosition(from);
			if (!retPath.empty && from.distanceL1(retPath.get(0)) > 1) {
				retPath = findPath(from, to, vehicleDirection)
			}
		}
		return retPath
	}
	
}

