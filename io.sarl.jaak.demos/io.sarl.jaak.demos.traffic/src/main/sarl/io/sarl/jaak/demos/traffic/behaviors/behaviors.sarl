package io.sarl.jaak.demos.traffic.behaviors

import io.sarl.core.Lifecycle
import io.sarl.jaak.demos.traffic.TrafficConstants
import io.sarl.jaak.demos.traffic.environment.GroundType
import io.sarl.jaak.demos.traffic.environment.Path
import io.sarl.jaak.demos.traffic.environment.Siren
import io.sarl.jaak.demos.traffic.logging.SimulationAgentLoggerCapacity
import io.sarl.jaak.environment.Perception
import io.sarl.jaak.environment.PhysicBody
import io.sarl.lang.core.Agent
import java.io.Serializable
import org.arakhne.afc.math.discrete.object2d.Point2i
import org.arakhne.afc.math.discrete.object2d.Vector2i
import io.sarl.jaak.demos.traffic.logging.SimulationEmergencyAgentLoggerCapacity

/** This class defines a standard driver.
 * 
 * @author $Author: sgalland$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 */
behavior StandardDriver {

	uses DrivingCapacity, Lifecycle, PhysicBody, GPSCapacity, SimulationAgentLoggerCapacity
	
	var previousOrientation : Vector2i

	val target : Point2i
	
	var path : Path
	
	new (owner : Agent, target : Point2i) {
		super(owner);
		this.target = target
	}
	
	def stopWhenEmergency(sirenPosition : Point2i, groundType : Serializable, direction : Vector2i) : boolean {
		// Do not stop on cross road.
		if (groundType !== GroundType::CROSS_ROAD) {
			var sirenDirection = new Vector2i
			sirenDirection.sub(sirenPosition, position)
			var dot = direction.dot(sirenDirection)
			if (dot >= 0) {
				return true
			}
		}
		return false
	}

	on Perception {
		synchronized(owner) {
			var groundType = occurrence.body.currentGroundType
			if (groundType === GroundType::AGENT_DESTROYER) {
				killMe
			}

			var direction = Vector2i::toOrientationVector(headingAngle)
	
			path = updatePath(path, position, target, direction)
			logPath(path, occurrence.currentTime)

			var siren = occurrence.body.getFirstPerceptionAtCurrentPosition(typeof(Siren))
			
			var stopForEmergencyVehicle = false
			
			if (siren != null) {
				var sirenPosition = siren.soundSourcePosition
				stopForEmergencyVehicle = stopWhenEmergency(sirenPosition, occurrence.body.currentGroundType, direction)
				logEmergencySirenSignal(sirenPosition, stopForEmergencyVehicle, occurrence.currentTime)
			}
			
			if (!stopForEmergencyVehicle && !occurrence.body.vehicleStop) {
				var motion : Vector2i = null
				if (path !== null && !path.empty) {
					motion = followPath(
						path,
						position,
						direction,
						previousOrientation,
						occurrence.body.perception,
						occurrence.body.groundPerception)
				}
				if (motion === null) {
					motion = driveRandomly(
						position,
						direction,
						previousOrientation,
						occurrence.body.perception,
						occurrence.body.groundPerception)
				}
				if (motion !== null && motion.lengthSquared > 0) {
					move(motion, true)
					this.previousOrientation = direction
				}
			}
		}
		synchronizeLogs
		synchronizeBody
	}
	
}

/** This class defines an emergency vehicle driver.
 * 
 * @author $Author: sgalland$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 */
behavior EmergencyDriver {

	uses DrivingCapacity, Lifecycle, PhysicBody, GPSCapacity, SimulationEmergencyAgentLoggerCapacity

	var previousOrientation : Vector2i

	var path : Path

	var target : Point2i

	new (owner : Agent, target : Point2i) {
		super(owner);
		this.target = target
	}

	on Perception {
		synchronized(owner) {
			if (occurrence.currentTime >= TrafficConstants::CRASH_TIME) {
				var groundType = occurrence.body.currentGroundType
				if (groundType === GroundType::EMERGENCY_LOCATION) {
					target = null
					path = null
					killMe
				}
	
				logDrivingDuringEmergencySituation(occurrence.currentTime)

				var direction = Vector2i::toOrientationVector(occurrence.body.headingAngle)
		
				path = updatePath(path, occurrence.body.position, target, direction)
				
				var motion : Vector2i = null
				if (path !== null && !path.empty) {
					motion = followPath(
						path,
						occurrence.body.position,
						direction,
						previousOrientation,
						occurrence.body.perception,
						occurrence.body.groundPerception)
				}
				
				if (motion !== null && motion.lengthSquared > 0) {
					move(motion, true)
					this.previousOrientation = direction
				}
	
				dropOff(new Siren())
			}
		}
		synchronizeLogs
		synchronizeBody
	}
	
}