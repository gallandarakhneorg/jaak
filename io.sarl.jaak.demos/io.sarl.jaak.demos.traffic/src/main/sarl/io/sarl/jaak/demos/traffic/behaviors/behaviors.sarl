package io.sarl.jaak.demos.traffic.behaviors

import io.sarl.core.Lifecycle
import io.sarl.jaak.demos.traffic.TrafficConstants
import io.sarl.jaak.demos.traffic.environment.physic.GroundType
import io.sarl.jaak.demos.traffic.environment.physic.Path
import io.sarl.jaak.demos.traffic.environment.physic.Siren
import io.sarl.jaak.environment.Perception
import io.sarl.jaak.environment.PhysicBody
import io.sarl.lang.core.Agent
import org.arakhne.afc.math.discrete.object2d.Point2i
import org.arakhne.afc.math.discrete.object2d.Vector2i
import org.arakhne.afc.math.continous.object2d.Vector2f
import java.util.UUID

/** This class defines a standard driver.
 * 
 * @author $Author: sgalland$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 */
behavior StandardDriver {

	uses DrivingCapacity, Lifecycle, PhysicBody, GPSCapacity
	
	var previousOrientation : Vector2i

	val target : Point2i
	
	var path : Path

	new (owner : Agent, target : Point2i) {
		super(owner);
		this.target = target
	}

	on Perception {
		synchronized(owner) {
			var groundType = occurrence.body.currentGroundType
			if (groundType === GroundType::AGENT_DESTROYER) {
				killMe
			}

			var direction = Vector2i::toOrientationVector(occurrence.body.headingAngle)
	
			path = updatePath(path, occurrence.body.position, target, direction)

			var siren = occurrence.body.getFirstPerception(typeof(Siren))
			
			var stopForUrgencyVehicle = false
			
			if (siren != null) {
				var sirenPosition = siren.soundSourcePosition
				var sirenDirection = new Vector2i
				sirenDirection.sub(sirenPosition, occurrence.body.position)
				var angle = occurrence.body.headingVector.angle(sirenDirection)
				if (angle >= 3*Math::PI/4) {
					System.out.println("STOP " + sirenPosition)
					stopForUrgencyVehicle = true
				}
			}
			
			if (!stopForUrgencyVehicle && !occurrence.body.vehicleStop) {
				var motion : Vector2i = null
				if (path !== null && !path.empty) {
					motion = followPath(
						path,
						occurrence.body.position,
						direction,
						previousOrientation,
						occurrence.body.perception,
						occurrence.body.groundPerception)
				}
				if (motion === null) {
					motion = driveRandomly(
						occurrence.body.position,
						direction,
						previousOrientation,
						occurrence.body.perception,
						occurrence.body.groundPerception)
				}
				if (motion !== null && motion.lengthSquared > 0) {
					move(motion, true)
					this.previousOrientation = direction
				}
			}
		}
		synchronizeBody
	}
	
}

/** This class defines an urgency vehicle driver.
 * 
 * @author $Author: sgalland$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 */
behavior UrgencyDriver {

	uses DrivingCapacity, Lifecycle, PhysicBody, GPSCapacity

	var previousOrientation : Vector2i

	val target : Point2i
	
	var path : Path

	new (owner : Agent, target : Point2i) {
		super(owner);
		this.target = target
	}

	on Perception {
		if (occurrence.currentTime >= TrafficConstants::CRASH_TIME) {
			synchronized(owner) {
				var groundType = occurrence.body.currentGroundType
				if (groundType === GroundType::URGENCY_LOCATION) {
					killMe
				}
	
				var direction = Vector2i::toOrientationVector(occurrence.body.headingAngle)
		
				path = updatePath(path, occurrence.body.position, target, direction)
				
				var motion : Vector2i = null
				if (path !== null && !path.empty) {
					motion = followPath(
						path,
						occurrence.body.position,
						direction,
						previousOrientation,
						occurrence.body.perception,
						occurrence.body.groundPerception)
				}
				
				if (motion !== null && motion.lengthSquared > 0) {
					move(motion, true)
					this.previousOrientation = direction
				}

				dropOff(new Siren())
			}
		}
		synchronizeBody
	}
	
}