package io.sarl.jaak.demos.traffic.behaviors

import io.sarl.core.Lifecycle
import io.sarl.jaak.demos.traffic.TrafficConstants
import io.sarl.jaak.demos.traffic.environment.GroundType
import io.sarl.jaak.demos.traffic.environment.Path
import io.sarl.jaak.demos.traffic.environment.Siren
import io.sarl.jaak.demos.traffic.logging.SimulationAgentLoggerCapacity
import io.sarl.jaak.demos.traffic.logging.SimulationEmergencyAgentLoggerCapacity
import io.sarl.jaak.environment.Perception
import io.sarl.jaak.environment.PhysicBody
import io.sarl.lang.core.Agent
import org.arakhne.afc.math.discrete.object2d.Point2i
import org.arakhne.afc.math.discrete.object2d.Vector2i

/** This class defines a standard driver.
 * 
 * @author $Author: sgalland$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 */
behavior StandardDriver {

	uses DrivingCapacity, Lifecycle, PhysicBody, GPSCapacity, SimulationAgentLoggerCapacity
	
	var previousOrientation : Vector2i

	val target : Point2i
	
	var path : Path
	
	var accelerationFactor = 0
	
	new (owner : Agent, target : Point2i) {
		super(owner);
		this.target = target
	}
	
	on Perception {
		synchronized(owner) {
			var groundType = occurrence.body.currentGroundType
			if (groundType === GroundType::AGENT_DESTROYER) {
				killMe
			}

			var siren = occurrence.body.getFirstPerceptionAtCurrentPosition(typeof(Siren))
	
			if (this.accelerationFactor > 0 && siren !== null) {
				this.accelerationFactor --
			} else {
				var direction = Vector2i::toOrientationVector(headingAngle)
		
				path = updatePath(path, position, target, direction)
				logPath(position, path, occurrence.currentTime)
					
				var stopForEmergencyVehicle = false
				
				if (siren != null) {
					var sirenPosition = siren.soundSourcePosition
					stopForEmergencyVehicle = isStopOnSiren(
						sirenPosition,
						occurrence.body.currentGroundType,
						position,
						direction)
					logEmergencySirenSignal(sirenPosition, stopForEmergencyVehicle, occurrence.currentTime)
				}
				
				if (!occurrence.body.vehicleStop) {
					if (stopForEmergencyVehicle) {
						var v = new Vector2i
						v.sub(siren.soundSourcePosition, position)
						var d = v.length
						if (d > 0) {
							this.accelerationFactor = Math::round(TrafficConstants::SIREN_RADIUS/d)
						} else {
							this.accelerationFactor = 0
						}
					} else {
						this.accelerationFactor = 0
					}

					var motion : Vector2i = null
					if (path !== null && !path.empty) {
						motion = followPath(
							path,
							position,
							direction,
							previousOrientation,
							occurrence.body.perception,
							occurrence.body.groundPerception)
					}
					if (motion === null) {
						motion = driveRandomly(
							position,
							direction,
							previousOrientation,
							occurrence.body.perception,
							occurrence.body.groundPerception)
					}
					if (motion !== null && motion.lengthSquared > 0) {
						move(motion, true)
						this.previousOrientation = direction
					}
				}
			}
		}
		synchronizeLogs
		synchronizeBody
	}
	
}

/** This class defines an emergency vehicle driver.
 * 
 * @author $Author: sgalland$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 */
behavior EmergencyDriver {

	uses DrivingCapacity, Lifecycle, PhysicBody, GPSCapacity, SimulationEmergencyAgentLoggerCapacity

	var previousOrientation : Vector2i

	var path : Path

	var target : Point2i

	new (owner : Agent, target : Point2i) {
		super(owner);
		this.target = target
	}

	on Perception {
		synchronized(owner) {
			if (occurrence.currentTime >= TrafficConstants::CRASH_TIME) {
				var groundType = occurrence.body.currentGroundType
				if (groundType === GroundType::EMERGENCY_LOCATION) {
					target = null
					path = null
					killMe
				}
	
				logDrivingDuringEmergencySituation(occurrence.currentTime)

				var direction = Vector2i::toOrientationVector(occurrence.body.headingAngle)
		
				path = updatePath(path, occurrence.body.position, target, direction)
				
				var motion : Vector2i = null
				if (path !== null && !path.empty) {
					motion = followPath(
						path,
						occurrence.body.position,
						direction,
						previousOrientation,
						occurrence.body.perception,
						occurrence.body.groundPerception)
				}
				
				if (motion !== null && motion.lengthSquared > 0) {
					move(motion, true)
					this.previousOrientation = direction
				}
	
				dropOff(new Siren())
			}
		}
		synchronizeLogs
		synchronizeBody
	}
	
}