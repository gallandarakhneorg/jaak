package io.sarl.jaak.demos.traffic

import io.sarl.core.Initialize
import io.sarl.jaak.demos.traffic.environment.physic.GroundType
import io.sarl.jaak.demos.traffic.environment.physic.MapUtil
import io.sarl.jaak.demos.traffic.environment.physic.TrafficLightGroup
import io.sarl.jaak.demos.traffic.environment.physic.TrafficLightManager
import io.sarl.jaak.demos.traffic.logging.SimulationLogger
import io.sarl.jaak.demos.traffic.spawn.StandardDriverSpawner
import io.sarl.jaak.demos.traffic.spawn.UrgencyDriverSpawner
import io.sarl.jaak.demos.traffic.ui.TrafficFrame
import io.sarl.jaak.demos.traffic.ui.TrafficPanel
import io.sarl.jaak.demos.traffic.util.Rectangle2iComparator
import io.sarl.jaak.environment.model.JaakEnvironment
import io.sarl.jaak.environment.spawner.JaakSpawner
import io.sarl.jaak.environment.time.TimeManager
import io.sarl.jaak.kernel.DefaultJaakTimeManager
import io.sarl.jaak.kernel.JaakKernelAgent
import io.sarl.lang.core.Agent
import java.awt.Color
import java.io.Serializable
import org.arakhne.afc.math.discrete.object2d.Point2i
import org.arakhne.afc.math.discrete.object2d.Rectangle2i
import org.arakhne.afc.math.discrete.object2d.Vector2i
import io.sarl.jaak.demos.traffic.environment.physic.TrafficInfluenceSolver

/** This class defines the simulation environment for the traffic simulation problem.
 * 
 * @author $Author: sgalland$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 */
agent TrafficSimulationProblem extends JaakKernelAgent {

	on Initialize {
		//TODO: Replace by the "super(occurrence)" syntax when introduced.
		super._handle_Initialize_0(occurrence)

		var uiPanel = new TrafficPanel
		addJaakListener(uiPanel)
		
		var uiFrame = new TrafficFrame(uiPanel, physicEnvironment.width, physicEnvironment.height, controller)
		addJaakListener(uiFrame)

		var logger = new SimulationLogger(uiPanel);
		addJaakListener(logger)

		fireEnvironmentChange
		uiFrame.visible = true
	}
	
	/* Create an instance of the time manager that must be used by
	 * the Jaak kernel.
	 * 
	 * @return the instance of time manager.
	 */
	def createTimeManager : TimeManager {
		new DefaultJaakTimeManager(1)
	}
		
	/** Replies if the simulator should stop when no more agent is simulated.
	 *
	 * @param t the current simulation time.
	 * @return <code>true</code> if the simulator could stop; otherwise <code>false</code>.
	 */
	def canStopSimulatorWhenNoMoreAgent(t : float) : boolean {
		return t > 0
	}
	
	/**
	 * Create an urgency driver spawner.
	 */
	def createUrgencySpawner(x : int, y : int, direction : Vector2i) : JaakSpawner {
		return new UrgencyDriverSpawner(
			physicEnvironment,
			TrafficConstants::URGENCY_DRIVER_BUDGET,
			x, y,
			direction)
	}
	
	/**
	 * Create a driver spawner.
	 */
	def createAgentSpawner(x : int, y : int, direction : Vector2i) : JaakSpawner {
		return new StandardDriverSpawner(
			physicEnvironment,
			TrafficConstants::STANDARD_DRIVER_BUDGET,
			x, y,
			direction)
	}
	
	def computeDirection(x : int, y : int) : Vector2i {
		if (x == 0) {
			return new Vector2i(1, 0)
		}
		if (y == 0) {
			return new Vector2i(0, 1)
		}
		if (x == physicEnvironment.width - 1) {
			return new Vector2i(-1, 0)
		}
		if (y == physicEnvironment.height - 1) {
			return new Vector2i(0, -1)
		}
		return null
	}

	/* Create the default spawner.
	 * 
	 * @return the default spawner or <code>null</code>.
	 */
	def createDefaultSpawner : JaakSpawner {
		return null // Avoid default spawner
	}

	/* Create the spawners to put on the environment
	 * at the start up of the simulation.
	 * 
	 * @return the start-up spawners.
	 */
	def createSpawners : JaakSpawner[] {
		var spawners = newArrayList
		var standardVehicleSpawners = MapUtil::standardVehicleSpawningPositions
		for (position : standardVehicleSpawners) {
			spawners.add(createAgentSpawner(position.x(), position.y(), computeDirection(position.x(), position.y())))
		}
		var urgencyVehicleSpawners = MapUtil::urgencyVehicleSpawningPositions
		for (position : urgencyVehicleSpawners) {
			spawners.add(createUrgencySpawner(position.x(), position.y(), computeDirection(position.x(), position.y())))
		}
		return spawners;
	}
	
	/* Create an instance of the environment that must
	 * be used by the Jaak kernel.
	 * 
	 * @return the instance of time manager.
	 */
	def createEnvironment(tm : TimeManager) : JaakEnvironment {
		var worldModel = MapUtil::getWorldModel

		var environment = new JaakEnvironment(worldModel.length, worldModel.get(0).length)
		environment.timeManager = tm
		environment.influenceSolver = new TrafficInfluenceSolver
		environment.wrapped = false
		var actionApplier = environment.actionApplier
	
		var trafficLightPositions = MapUtil::trafficLights
		
		for (x : 0..<worldModel.length) {
			for (y : 0..<worldModel.get(x).length) {
				var type = worldModel.get(x).get(y)
				if (type !== null) {
					actionApplier.setGroundType(x, y, type)
				}
			}
		}
		
		// Add traffic lights
		var trafficLights = <Rectangle2i, TrafficLightGroup>newTreeMap(new Rectangle2iComparator)
		
		for (entry : trafficLightPositions.entrySet) {
			var r = environment.detectCrossRoad(entry.key.x(), entry.key.y())
			if (r !== null) {
				var group = trafficLights.get(r)
				if (group === null) {
					group = new TrafficLightGroup(r)
					trafficLights.put(r, group)
				}
				var light = group.createTrafficLight(entry.value)
				actionApplier.putObject(entry.key.x(), entry.key.y(), light)
			}
		}

		var manager = new TrafficLightManager
		manager += trafficLights.values
		environment.endogenousEngine = manager

		manager.initialize

		return environment
	}
	
	def detectCrossRoad(env : JaakEnvironment, x : int, y : int) : Rectangle2i {
		var p : Point2i = null
		if (env.getGroundType(x + 1, y) === GroundType::CROSS_ROAD) {
			var i = y - 1
			while (env.getGroundType(x + 1, i) === GroundType::CROSS_ROAD) {
				i--
			}
			p = new Point2i(x + 1, i + 1)
		}
		else if (env.getGroundType(x - 1, y) === GroundType::CROSS_ROAD) {
			var i = y - 1
			while (env.getGroundType(x - 2, i) === GroundType::CROSS_ROAD) {
				i--
			}
			p = new Point2i(x - 2, i + 1)
		}
		else if (env.getGroundType(x, y - 1) === GroundType::CROSS_ROAD) {
			var i = y - 2
			while (env.getGroundType(x, i) === GroundType::CROSS_ROAD) {
				i--
			}
			i++
			var j = x - 1
			while (env.getGroundType(j, i) === GroundType::CROSS_ROAD) {
				j--
			}
			p = new Point2i(j + 1, i)
		}
		else if (env.getGroundType(x, y + 1) === GroundType::CROSS_ROAD) {
			var i = x - 1
			while (env.getGroundType(i, y + 1) === GroundType::CROSS_ROAD) {
				i--
			}
			p = new Point2i(i + 1, y + 1)
		}
		if (p !== null) {
			return new Rectangle2i(p.x(), p.y(), 1, 1)
		}
		return null
	}
	
	def isRoad(t : Serializable) : boolean {
		if (t instanceof GroundType) {
			return t.canDrive
		}
		return false
	}
	
	def normalizeColor(p: int) : Color {
		var c = new Color(p)
		return new Color(c.red, c.green, c.blue, 0)
	}
	
	/* Replies the type of the agents to spawn.
	 *
	 * @param spawner - the spawner that will create the agent.
	 */
	def getSpawnableAgentType(spawner : JaakSpawner) : Class<? extends Agent> {
		return typeof(Driver)
	}
	
}