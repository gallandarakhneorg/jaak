/*
 * $Id$
 *
 * Jaak environment model is an open-source multiagent library.
 * More details on http://www.sarl.io
 *
 * Copyright (C) 2014 St√©phane GALLAND.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.sarl.jaak.kernel

import io.sarl.core.Behaviors
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Schedules
import io.sarl.jaak.environment.BodyCreated
import io.sarl.jaak.environment.Perception
import io.sarl.jaak.environment.SimulationStarted
import io.sarl.jaak.environment.SimulationStopped
import io.sarl.jaak.environment.model.JaakEnvironment
import io.sarl.jaak.environment.spawner.JaakSpawner
import io.sarl.jaak.environment.time.TimeManager
import io.sarl.jaak.util.RandomNumber
import io.sarl.lang.core.Address
import io.sarl.lang.core.Agent
import io.sarl.util.Scopes
import java.util.Collections
import java.util.List
import java.util.Map
import java.util.UUID
import java.util.concurrent.atomic.AtomicBoolean

/** Provide the core agent which is responsible of the Jaak environment.
 * 
 * @author $Author: sgalland$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 */
agent JaakKernelAgent {

	uses DefaultContextInteractions, Lifecycle, Schedules, Behaviors
	
	val environmentListeners : List<JaakListener> = newArrayList
	val removedAgents : List<UUID> = newLinkedList
	val addedAgents : Map<UUID, TurtleCreated> = newTreeMap(null)
	val isWaitingInfluences = new AtomicBoolean(false)
	var receivedInfluences : long = 0
	val controller : JaakController = new JaakKernelController
	var physicSpace : JaakPhysicSpace
	var defaultAddressInPhysicSpace : Address
	var physicEnvironment : JaakEnvironment
	var timeManager : TimeManager
	var spawners : JaakSpawner[]
	var defaultSpawner : JaakSpawner
	var awaitingSpawnedAgents = <UUID>newLinkedList 
	
	def addJaakListener(listener : JaakListener) {
		synchronized(environmentListeners) {
			environmentListeners += listener
		}
	}
	
	def removeJaakListener(listener : JaakListener) {
		synchronized(environmentListeners) {
			environmentListeners -= listener
		}
	}
	
	def fireSimulationStarted() {
		var list : JaakListener[]
		synchronized(environmentListeners) {
			list = newArrayOfSize(environmentListeners.size)
			environmentListeners.toArray(list)
		}
		var evt = new JaakEvent(this,
			physicEnvironment,
			Collections.unmodifiableCollection(spawners),
			timeManager.currentTime,
			timeManager.lastStepDuration
		)
		for(listener : list) {
			listener.simulationStarted(evt)
		}
	}

	def fireSimulationStopped() {
		var list : JaakListener[]
		synchronized(environmentListeners) {
			list = newArrayOfSize(environmentListeners.size)
			environmentListeners.toArray(list)
		}
		var evt = new JaakEvent(this,
			physicEnvironment,
			Collections.unmodifiableCollection(spawners),
			timeManager.currentTime,
			timeManager.lastStepDuration
		)
		for(listener : list) {
			listener.simulationStopped(evt)
		}
	}

	def fireEnvironmentChange() {
		var list : JaakListener[]
		synchronized(environmentListeners) {
			list = newArrayOfSize(environmentListeners.size)
			environmentListeners.toArray(list)
		}
		var evt = new JaakEvent(this,
			physicEnvironment,
			Collections.unmodifiableCollection(spawners),
			timeManager.currentTime,
			timeManager.lastStepDuration
		)
		for(listener : list) {
			listener.environmentStateChanged(evt)
		}
	}

	on Initialize {
		var spaceId = JaakPhysicSpaceConstants.getSpaceIDInContext(defaultContext)
		physicSpace = defaultContext.getOrCreateSpaceWithSpec(typeof(JaakPhysicSpaceSpecification), spaceId, asEventListener)
		// Ensure that the agent is the creator of the space.
		if (physicSpace.creatorID !== null && physicSpace.creatorID != ID) {
			killMe
		} else {
			// Create the physic environment
			defaultAddressInPhysicSpace = new Address(physicSpace.ID, ID)
			timeManager = createTimeManager
			physicEnvironment = createEnvironment(timeManager)
			defaultSpawner = createDefaultSpawner
			var p = createSpawners
			if (p === null || p.empty) {
				if (defaultSpawner !== null) {
					spawners = Collections::singletonList(defaultSpawner)
				} else {
					spawners = Collections::emptyList
				}
			} else {
				spawners = p
			}
			(controller as JaakKernelController).initialize(
				defaultSpace,
				defaultAddress,
				timeManager
			)
		}
	}
	
	on Destroy [physicEnvironment !== null] {
		isWaitingInfluences.set(false)
		physicSpace.destroy
		physicSpace = null
		physicEnvironment = null
	}
	
	on TurtleCreated [occurrence.isValid3] {
		var b : boolean
		var e : boolean
		synchronized(awaitingSpawnedAgents) {
			b = awaitingSpawnedAgents.remove(occurrence.source.UUID)
			e = awaitingSpawnedAgents.empty
		}
		if (!b) {
			synchronized(addedAgents) {
				addedAgents.put(
					occurrence.source.UUID,
					occurrence
				)
			}
		} else if (e) {
			synchronized(this) {
				terminatePreAgentExecution
			}
		}
	}
	
	on TurtleDestroyed [occurrence.isValid3] {
		synchronized(removedAgents) {
			removedAgents.add(occurrence.source.UUID)
		}
		doAgentSynchronization
	}

	on AgentInfluence [occurrence.isValid] {
		synchronized(this) {
			var body = physicEnvironment.getBodyFor(occurrence.influence.emitter.turtleId)
			if (body !== null) {
				body.influence(occurrence.influence)
			}
		}
	}
	
	on SynchronizeBody [occurrence.isValid2] {
		doAgentSynchronization
	}
	
	def doAgentSynchronization {
		synchronized(this) {
			receivedInfluences++
			if (receivedInfluences >= physicEnvironment.turtleCount) {
				isWaitingInfluences.set(false)
				val ctrl = controller as JaakKernelController
				var duration = ctrl.waitingDuration
				if (duration > 0) {
					in(duration) [
						ctrl.wakeSimulator
					]
				} else {
					ctrl.wakeSimulator
				}
			}
		}
	}
	
	on SimulationStarted [occurrence.fromMe] {
		fireSimulationStarted
		runPreAgentExecution
	}

	on ExecuteSimulationStep [occurrence.fromMe] {
		runPostAgentExecution
		runPreAgentExecution
	}

	on SimulationStopped [occurrence.fromMe] {
		fireSimulationStopped
		killMe
	}

	def isValid(evt : AbstractStampedEvent) : boolean {
		physicEnvironment !== null
		&& evt.source.spaceId == physicSpace.ID
		&& isWaitingInfluences.get
		&& timeManager.currentTime <= evt.currentTime
	}
	
	def isValid2(evt : AbstractStampedEvent) : boolean {
		physicEnvironment !== null
		&& isWaitingInfluences.get
		&& timeManager.currentTime <= evt.currentTime
	}
	
	def isValid3(evt : AbstractStampedEvent) : boolean {
		physicEnvironment !== null
	}

	/* Run the tasks before the agent executions.
	 */
	def runPreAgentExecution {
		if (physicEnvironment !== null) {
			synchronized(awaitingSpawnedAgents) {
				awaitingSpawnedAgents.clear
			
				if (spawners !== null) {
					var factory = physicEnvironment.turtleBodyFactory
					
					for(spawner : spawners) {
						var id = UUID::randomUUID
						var body = spawner.spawnBodyFor(
			            		  id,
			            		  ID,
			            		  factory,
			            		  this.timeManager,
			            		  null)
						if (body !== null) {
			            	spawnInContextWithID(
			            		getSpawnableAgentType(spawner),
			            		id, 
			            		defaultContext)
				            emit(new BodyCreated(
				            	this.timeManager.currentTime,
				            	this.timeManager.lastStepDuration,
				            	body,
				            	physicEnvironment.width,
				            	physicEnvironment.height),
				            	Scopes::addresses(new Address(defaultSpace.ID, id)))
				            awaitingSpawnedAgents += id
			            }
					}
		
					synchronized(removedAgents) {
						var iterator = this.removedAgents.iterator
						while (iterator.hasNext) {
							var adr = iterator.next
							iterator.remove
							physicEnvironment.removeBodyFor(adr)
						}
					}
		
					synchronized(addedAgents) {
						var iterator = this.addedAgents.entrySet.iterator
						var creator : AgentBodyCreator = new AgentBodyCreator
						while (iterator.hasNext) {
							var p = iterator.next
							iterator.remove
							if (physicEnvironment.getBodyFor(p.key) === null) {
								creator.set(p.value) 					
								if (creator.isPositionForced(physicEnvironment)) {
									defaultSpawner.spawnBodyFor(
						            		  p.key,
						            		  ID,
						            		  factory,
						            		  this.timeManager,
						            		  creator)
								} else {
									var spawner = this.spawners.get(
										RandomNumber.nextInt(this.spawners.length)
									)
									var body = spawner.spawnBodyFor(
						            		  p.key,
						            		  ID,
						            		  factory,
						            		  this.timeManager,
						            		  creator)
						            emit(new BodyCreated(
						            	this.timeManager.currentTime,
						            	this.timeManager.lastStepDuration,
						            	body,
						            	physicEnvironment.width,
						            	physicEnvironment.height),
						            	Scopes::addresses(new Address(defaultSpace.ID, p.key)))
								}
							}
						}
					}
				}
				
				if (awaitingSpawnedAgents.empty) {
					terminatePreAgentExecution
				}
			}
		}
	}
	
	/** Replies if the simulator should stop when no more agent is simulated.
	 *
	 * @param t the current simulation time.
	 * @return <code>true</code> if the simulator could stop; otherwise <code>false</code>.
	 */
	def canStopSimulatorWhenNoMoreAgent(t : float) : boolean {
		return false
	}
	
	def terminatePreAgentExecution {
		physicEnvironment.runPreTurtles
		//		
		// Wait for agents only if a turtle is known
		receivedInfluences = 0
		isWaitingInfluences.set(true)
		if (physicEnvironment.turtleCount > 0) {
			var timeout = controller.simulationStepTimeOut
			if (timeout > 0) {
				val time = timeManager.currentTime
				in(timeout) [
					if (isWaitingInfluences.get && timeManager.currentTime == time) {
						// Timeout => wake the simulator
						(controller as JaakKernelController).wakeSimulator
					}
				]
			}
			physicEnvironment.apply [
				var evt = new Perception(
					timeManager.currentTime,
					timeManager.lastStepDuration, 
					it)
				evt.source = defaultAddressInPhysicSpace
				physicSpace?.notifyPerception(evt)
			]
		} else if (!canStopSimulatorWhenNoMoreAgent(timeManager.currentTime)) {
			// Have no turtle => proceed to next step of the life cycle
			(controller as JaakKernelController).wakeSimulator
		} else {
			fireEnvironmentChange
			fireSimulationStopped
			killMe
		}
	}

	/* Run the tasks after the agent executions.
	 */
	def runPostAgentExecution {
		isWaitingInfluences.set(false)
		physicEnvironment.runPostTurtles
		timeManager.increment
		fireEnvironmentChange
	}
	
	/* Create an instance of the time manager that must be used by
	 * the Jaak kernel.
	 * 
	 * @return the instance of time manager.
	 */
	def createTimeManager : TimeManager {
		new DefaultJaakTimeManager()
	}
	
	def createDefaultSpawner() : JaakSpawner {
		throw new UnsupportedOperationException("must be overridden")
	}
	
	/* Create the spawners to put on the environment
	 * at the start up of the simulation.
	 * 
	 * @return the start-up spawners.
	 */
	def createSpawners() : JaakSpawner[] {
		#[] 
	}
	
	/* Create an instance of the environment that must
	 * be used by the Jaak kernel.
	 * 
	 * @param tm - the time manager to associated to the environment.
	 * @return the instance of time manager.
	 */
	def createEnvironment(tm : TimeManager) : JaakEnvironment {
		throw new UnsupportedOperationException("must be overridden")
	}

	/* Replies the type of the agents to spawn.
	 *
	 * @param spawner - the spawner that will create the agent.
	 */
	def getSpawnableAgentType(spawner : JaakSpawner) : Class<? extends Agent> {
		throw new UnsupportedOperationException("must be overridden")
	}

}