/*
 * $Id$
 *
 * Jaak environment model is an open-source multiagent library.
 * More details on http://www.sarl.io
 *
 * Copyright (C) 2014 St√©phane GALLAND.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.sarl.jaak.environment.model;

import io.sarl.jaak.environment.ValidationResult;
import io.sarl.jaak.environment.body.TurtleBody;
import io.sarl.jaak.environment.endogenous.AutonomousEndogenousProcess;
import io.sarl.jaak.environment.influence.Influence;
import io.sarl.jaak.environment.perception.Burrow;
import io.sarl.jaak.environment.perception.EnvironmentalObject;
import io.sarl.jaak.environment.perception.ObjectManipulator;
import io.sarl.jaak.environment.perception.Obstacle;
import io.sarl.jaak.environment.perception.Substance;
import io.sarl.jaak.environment.solver.ActionApplier;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedList;
import java.util.Map;
import java.util.TreeMap;

import org.arakhne.afc.math.discrete.object2d.Point2i;

/** This class defines grid for the Jaak environment model.
 *
 * @author $Author: sgalland$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 */
class JaakGrid implements GridModel, ActionApplier {

	private final int width;
	private final int height;
	private final GridCell[][] grid;
	private final ObjectManipulator objectManipulator;
	private final Collection<AutonomousEndogenousProcess> autonomousProcesses = new LinkedList<>();

	/**
	 * @param width is the width of the grid.
	 * @param height is the height of the grid.
	 * @param objectManipulator is the object which is permitting to manipulate
	 * the environmental objects.
	 */
	public JaakGrid(int width, int height, ObjectManipulator objectManipulator) {
		assert (width > 0);
		assert (height > 0);
		assert (objectManipulator != null);
		this.width = width;
		this.height = height;
		this.grid = new GridCell[width][height];
		this.objectManipulator = objectManipulator;
	}

	/** Replies the width of the grid.
	 *
	 * @return the width of the grid.
	 */
	@Override
	public int getWidth() {
		return this.width;
	}

	/** Replies the height of the grid.
	 *
	 * @return the height of the grid.
	 */
	@Override
	public int getHeight() {
		return this.height;
	}

	private GridCell getCell(int x, int y, boolean createNew) {
		try {
			GridCell cell = this.grid[x][y];
			if (cell == null && createNew) {
				cell = new GridCell();
				this.grid[x][y] = cell;
			}
			return cell;
		} catch (Throwable exception) {
			return null;
		}
	}

	/** Run the autonomous environmental processes.
	 *
	 * @param currentTime is the current simulation time
	 * @param simulationStepDuration is the duration of the current simulation step.
	 * @return the influences generated by the autonomous processes.
	 */
	public synchronized Collection<Influence> runAutonomousProcesses(float currentTime, float simulationStepDuration) {
		Collection<Influence> influences = new LinkedList<>();
		Influence influence;
		for (AutonomousEndogenousProcess process : this.autonomousProcesses) {
			influence = process.runAutonomousEndogenousProcess(currentTime, simulationStepDuration);
			if (influence != null) {
				influences.add(influence);
			}
		}
		return influences;
	}

	private void removeCell(GridCell cell, int x, int y) {
		assert (cell != null);
		if (cell.getTurtleCount() == 0
				&& cell.getEnvironmentObjects().isEmpty()
				&& cell.getObstacle() == null
				&& cell.getGroundType() == null) {
			this.grid[x][y] = null;
		}
	}

	/** Replies the turtle body on the cell at the
	 * given coordinate.
	 *
	 * @param x is the coordinate of the cell.
	 * @param y is the coordinate of the cell.
	 * @return the turtle body at the given position, or
	 * <code>null</code> if no turtle body is located at
	 * the given position.
	 */
	@Override
	public synchronized TurtleBody getTurtle(int x, int y) {
		GridCell cell = getCell(x, y, false);
		return (cell != null) ? cell.getUnburrowedTurtle() : null;
	}

	/** Replies the turtle bodies on the cell at the
	 * given coordinate, even if they are in a burrow.
	 *
	 * @param x is the coordinate of the cell.
	 * @param y is the coordinate of the cell.
	 * @return the turtle bodies at the given position.
	 */
	public synchronized Collection<TurtleBody> getTurtles(int x, int y) {
		GridCell cell = getCell(x, y, false);
		if (cell != null) {
			return cell.getTurtles();
		}
		return Collections.emptyList();
	}

	/** Replies if the cell at the given position is able to contains
	 * a new turtle.
	 * <p>
	 * Any coordinate outside the environment grid is assumed to be
	 * not a free cell.
	 *
	 * @param x is the coordinate of the cell.
	 * @param y is the coordinate of the cell.
	 * @return <code>true</code> if the cell may contains a new turtle,
	 * <code>false</code> if a turtle is already on the cell or
	 * if the cell is not traversable.
	 */
	public synchronized boolean isFree(int x, int y) {
		if (x >= 0 && y >= 0 && x < this.width && y < this.height) {
			GridCell cell = getCell(x, y, false);
			return cell == null
					|| (cell.getObstacle() == null
					&& cell.getUnburrowedTurtle() == null);
		}
		return false;
	}

	/** Replies the type of the ground.
	 *
	 * @param x is the coordinate of the cell.
	 * @param y is the coordinate of the cell.
	 * @return the type of the group, or <code>null</code>.
	 */
	public Serializable getGroundType(int x, int y) {
		if (x >= 0 && y >= 0 && x < this.width && y < this.height) {
			GridCell cell = getCell(x, y, false);
			if (cell != null) {
				return cell.getGroundType();
			}
		}
		return null;
	}
	
	/** Replies the type of the ground.
	 *
	 * @param x is the coordinate of the cell.
	 * @param y is the coordinate of the cell.
	 * @param type is the type of the group, or <code>null</code>.
	 */
	public void setGroundType(int x, int y, Serializable type) {
		if (x >= 0 && y >= 0 && x < this.width && y < this.height) {
			GridCell cell = getCell(x, y, true);
			if (cell != null) {
				cell.setGroundType(type);
			}
		}
	}


	/** Replies if the cell at the given position is able to contains
	 * an obstacle.
	 * <p>
	 * Any coordinate outside the environment grid is assumed to be an
	 * obstacle.
	 *
	 * @param x is the coordinate of the cell.
	 * @param y is the coordinate of the cell.
	 * @return <code>true</code> if the cell contains an obstacle,
	 * <code>false</code> otherwise.
	 */
	public synchronized boolean hasObstacle(int x, int y) {
		if (x >= 0 && y >= 0 && x < this.width && y < this.height) {
			GridCell cell = getCell(x, y, false);
			return cell != null && cell.getObstacle() != null;
		}
		return true;
	}

	/** Replies the environmental objects on the cell at the
	 * given coordinate.
	 *
	 * @param x is the coordinate of the cell.
	 * @param y is the coordinate of the cell.
	 * @return the environmental objects at the given position,
	 * never <code>null</code>.
	 */
	@Override
	public synchronized Collection<EnvironmentalObject> getObjects(int x, int y) {
		GridCell cell = getCell(x, y, false);
		if (cell == null) {
			return Collections.emptyList();
		}
		Obstacle o = cell.getObstacle();
		if (o != null) {
			return Collections.<EnvironmentalObject>singleton(o);
		}
		return Collections.unmodifiableCollection(cell.getEnvironmentObjects().values());
	}

	/** Replies the environmental object on the cell at the
	 * given coordinate, and with the given id.
	 *
	 * @param x is the coordinate of the cell.
	 * @param y is the coordinate of the cell.
	 * @param identifier is the identifier of the object to reply.
	 * @return the environmental objects at the given position,
	 * or <code>null</code>.
	 */
	@Override
	public synchronized EnvironmentalObject getObject(int x, int y, String identifier) {
		GridCell cell = getCell(x, y, false);
		if (cell == null) {
			return null;
		}
		Obstacle o = cell.getObstacle();
		if (o != null) {
			return null;
		}
		return cell.getEnvironmentObjects().get(identifier);
	}

	/** Put the given turtle body inside the cell at the given position.
	 * <p>
	 * The turtle body may be not put in the cell if a turtle body
	 * is already located on the cell.
	 *
	 * @param x is the coordinate of the cell.
	 * @param y is the coordinate of the cell.
	 * @param body is the turtle body to put in the cell.
	 * @return <code>true</code> if the body was successfully added,
	 * <code>false</code> otherwise
	 */
	@Override
	public synchronized boolean putTurtle(int x, int y, TurtleBody body) {
		GridCell cell = getCell(x, y, true);
		assert (cell != null);
		return cell.addTurtle(body);
	}

	/** Remove the given turtle body from the cell at the given position.
	 * <p>
	 * The turtle body may be not removed from the cell if the turtle body
	 * inside is not the same as the given one.
	 *
	 * @param x is the coordinate of the cell.
	 * @param y is the coordinate of the cell.
	 * @param body is the turtle body to remove from the cell.
	 * @return <code>true</code> if the body was successfully removed,
	 * <code>false</code> otherwise
	 */
	@Override
	public synchronized boolean removeTurtle(int x, int y, TurtleBody body) {
		GridCell cell = getCell(x, y, false);
		if (cell != null) {
			if (cell.removeTurtle(body)) {
				removeCell(cell, x, y);
				return true;
			}
		}
		return false;
	}

	/** Move a turtle body from a cell to an other cell.
	 * <p>
	 * The move of the body may be discarted if
	 * {@link #removeTurtle(int,int,TurtleBody)} on the
	 * starting cell is replying <code>false</code>, or
	 * if {@link #putTurtle(int, int, TurtleBody)} on
	 * the targeting cell is replying <code>false</code>.
	 *
	 * @param fromx is the coordinate of the starting cell.
	 * @param fromy is the coordinate of the starting cell.
	 * @param tox is the coordinate of the targeting cell.
	 * @param toy is the coordinate of the targeting cell.
	 * @param body is the turtle body to move.
	 * @return <code>true</code> if the turtle body was successfully
	 * moved, otherwise <code>false</code>
	 */
	public synchronized boolean moveTurtle(int fromx, int fromy, int tox, int toy, TurtleBody body) {
		if (fromx == tox && fromy == toy) {
			return false;
		}
		GridCell fromcell = getCell(fromx, fromy, false);
		if (fromcell != null) {
			GridCell tocell = getCell(tox, toy, false);
			if (tocell != null) {

				if (fromcell.removeTurtle(body)) {
					if (tocell.addTurtle(body)) {
						removeCell(fromcell, fromx, fromy);
						return true;
					}
					// Restore the previous cell state
					fromcell.addTurtle(body);
				}

			}
		}
		return false;
	}

	/** Put the given environmental object inside the cell at the given position.
	 * <p>
	 * The environmental object may be not put in the cell if the
	 * internal data structure is not able to receive it.
	 *
	 * @param x is the coordinate of the cell.
	 * @param y is the coordinate of the cell.
	 * @param object is the environmental object to put in the cell.
	 * @return the added object, not always the given object in the case
	 * of substances.
	 */
	@Override
	public synchronized EnvironmentalObject putObject(int x, int y, EnvironmentalObject object) {
		assert (object != null);
		EnvironmentalObject change = null;
		GridCell cell = getCell(x, y, true);
		if (cell != null) {
			String id = object.getEnvironmentalObjectIdentifier();

			Obstacle obs = cell.getObstacle();
			if (obs != null) {
				return null;
			}

			if (object instanceof Substance) {
				EnvironmentalObject currentObject = cell.getEnvironmentObjects().get(id);
				if (currentObject instanceof Substance) {
					Substance currentSubstance = (Substance) currentObject;
					Substance newObject = (Substance) object;
					change = this.objectManipulator.combine(currentSubstance, newObject, true);
					if (change != null) {
						this.objectManipulator.setPosition(object, x, y);
					}
					if (currentSubstance.isDisappeared()) {
						removeObject(x, y, currentObject);
					}
					return change;
				}
			} else if (object instanceof Burrow) {
				cell.createBurrow();
			}

			
			if (object instanceof Obstacle) {
				cell.createObstacle((Obstacle) object);
			} else {
				cell.getEnvironmentObjects().put(id, object);
			}
			this.objectManipulator.setPosition(object, x, y);
			if (object instanceof AutonomousEndogenousProcess) {
				this.autonomousProcesses.add((AutonomousEndogenousProcess) object);
			}
			change = object;
		}
		return change;
	}

	/** Remove the given environmental object from the cell at the given position.
	 * <p>
	 * The environmental object may be not removed from the cell if the
	 * internal data structure is not able to remove it.
	 *
	 * @param x is the coordinate of the cell.
	 * @param y is the coordinate of the cell.
	 * @param object is the environmental object to remove from the cell.
	 * @return the removed object, not always the given object in the case
	 * of substances.
	 */
	@Override
	public synchronized EnvironmentalObject removeObject(int x, int y, EnvironmentalObject object) {
		EnvironmentalObject change = null;
		GridCell cell = getCell(x, y, false);
		if (cell != null) {
			Obstacle obs = cell.getObstacle();
			if (obs != null && obs != object) {
				return null;
			}

			String id = object.getEnvironmentalObjectIdentifier();
			if (object instanceof Substance) {
				Substance oldSubstance = (Substance) object;

				EnvironmentalObject oldObject = cell.getEnvironmentObjects().get(id);
				if (oldObject instanceof Substance) {
					Substance currentSubstance = (Substance) oldObject;
					change = this.objectManipulator.combine(currentSubstance, oldSubstance, false);
					if (change == null || !currentSubstance.isDisappeared()) {
						return change;
					}
				}
			}

			EnvironmentalObject obj;

			if (obs != null) {
				obj = obs;
			} else  {
				obj = cell.getEnvironmentObjects().remove(id);
			}

			if (obj != null) {
				if (change == null) {
					change = obj;
				}
				if (obs == obj) {
					cell.deleteObstacle();
				} else if (obj instanceof Burrow) {
					cell.deleteBurrow();
				}
				this.objectManipulator.setPosition(obj, Integer.MIN_VALUE, Integer.MIN_VALUE);
				if (obj instanceof AutonomousEndogenousProcess) {
					this.autonomousProcesses.remove(obj);
				}
			}
		}
		return change;
	}

	/** Remove all the environmental objects on the given cell.
	 *
	 * @param x is the position of the cell.
	 * @param y is the position of the cell.
	 * @return the removed objects.
	 */
	@Override
	public synchronized Collection<EnvironmentalObject> removeObjects(int x, int y) {
		Collection<EnvironmentalObject> removedObjects = new ArrayList<>();
		GridCell cell = getCell(x, y, false);
		if (cell != null) {
			Obstacle obs = cell.getObstacle();
			if (obs != null) {
				removedObjects.add(obs);
			}
			cell.deleteObstacle();

			removedObjects.addAll(cell.getEnvironmentObjects().values());
			cell.getEnvironmentObjects().clear();

			for (EnvironmentalObject obj : removedObjects) {
				if (obj instanceof Burrow) {
					cell.deleteBurrow();
				}
				this.objectManipulator.setPosition(obj, Integer.MIN_VALUE, Integer.MIN_VALUE);
				if (obj instanceof AutonomousEndogenousProcess) {
					this.autonomousProcesses.remove(obj);
				}
			}
		}
		return removedObjects;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean setPhysicalState(int x, int y, int mx, int my, float headingAngle, float speed, TurtleBody body) {
		if (body instanceof RealTurtleBody) {
			((RealTurtleBody) body).setPhysicalState(x, y, mx, my, headingAngle, speed);
			return true;
		}
		return false;
	}

	/** {@inheritDoc}
	 */
	@Override
	public ValidationResult validatePosition(boolean isWrapped, boolean allowDiscard, Point2i position) {
		if (allowDiscard
			&& (position.x() < 0
				|| position.x() >= getWidth()
				|| position.y() < 0
				|| position.y() >= getHeight())) {
			return ValidationResult.DISCARDED;
		}

		ValidationResult change = ValidationResult.NO_CHANGE;

		// Check X coordinate to be on grid
		while (position.x() < 0) {
			if (isWrapped) {
				int delta = -position.x();
				position.setX(getWidth() - delta);
				change = ValidationResult.WRAPPED;
			} else {
				position.setX(0);
				change = ValidationResult.CLIPPED;
			}
		}

		while (position.x() >= getWidth()) {
			if (isWrapped) {
				int delta = position.x() - getWidth();
				position.setX(delta);
				change = ValidationResult.WRAPPED;
			} else {
				position.setX(getWidth() - 1);
				change = ValidationResult.CLIPPED;
			}
		}

		// Check Y coordinate to be on grid
		while (position.y() < 0) {
			if (isWrapped) {
				int delta = -position.y();
				position.setY(getHeight() - delta);
				change = ValidationResult.WRAPPED;
			} else {
				position.setY(0);
				change = ValidationResult.CLIPPED;
			}
		}

		while (position.y() >= getHeight()) {
			if (isWrapped) {
				int delta = position.y() - getHeight();
				position.setY(delta);
				change = ValidationResult.WRAPPED;
			} else {
				position.setY(getHeight() - 1);
				change = ValidationResult.CLIPPED;
			}
		}

		return change;
	}

	/** This class defines cell of the grid for the Jaak environment model.
	 *
	 * @author $Author: sgalland$
	 * @version $FullVersion$
	 * @mavengroupid $GroupId$
	 * @mavenartifactid $ArtifactId$
	 */
	private class GridCell {

		/** Turtle in the cell.
		 */
		private TurtleBody turtle;

		/** Burrow in the cell.
		 */
		private Collection<TurtleBody> burrowedTurtles;

		/** Count of burrows on the cell.
		 */
		private int burrowCount;

		/** Objects in the cell.
		 */
		private final Map<String, EnvironmentalObject> environmentObjects = new TreeMap<>();

		/** Obstacle.
		 */
		private Obstacle obstacle;

		/** GroundType.
		 */
		private Serializable groundType;

		/**
		 */
		public GridCell() {
			//
		}

		/** Replies the modified collection of environment objects.
		 *
		 * @return the objects in the cell.
		 */
		public Map<String, EnvironmentalObject> getEnvironmentObjects() {
			return this.environmentObjects;
		}

		/** Replies the number of turtles in this cell.
		 *
		 * @return the number of turtles in this cell.
		 */
		public int getTurtleCount() {
			if (this.obstacle != null) {
				return 0;
			}
			if (this.burrowedTurtles != null) {
				return this.burrowedTurtles == null ? 0 : this.burrowedTurtles.size();
			}
			return this.turtle != null ? 1 : 0;
		}

		/** Create a burrow in the cell.
		 */
		public void createBurrow() {
			if (this.burrowedTurtles == null) {
				this.burrowedTurtles = new ArrayList<>();
				if (this.turtle != null) {
					this.burrowedTurtles.add(this.turtle);
					this.turtle = null;
				}
			}
			++this.burrowCount;
		}

		/** Delete a burrow in the cell.
		 */
		public void deleteBurrow() {
			--this.burrowCount;
			if (this.burrowCount <= 0) {
				this.burrowCount = 0;
				if (this.burrowedTurtles != null) {
					this.burrowedTurtles = null;
					this.turtle = null;
				}
			}
		}

		/** Replies the turtle (not burrowed) on this cell.
		 *
		 * @return the turtle on this cell, or <code>null</code>.
		 */
		public TurtleBody getUnburrowedTurtle() {
			return this.obstacle != null ? null : this.turtle;
		}

		/** Replies the turtles (even if burrowed) on this cell.
		 *
		 * @return the turtles on this cell.
		 */
		public Collection<TurtleBody> getTurtles() {
			if (this.obstacle == null) {
				if (this.burrowedTurtles != null) {
					return Collections.unmodifiableCollection(this.burrowedTurtles);
				}
				if (this.turtle != null) {
					return Collections.singleton(this.turtle);
				}
			}
			return Collections.emptyList();
		}

		/** Put the given turtle body inside the cell.
		 * <p>
		 * The turtle body may be not put in the cell if a turtle body
		 * is already located on the cell.
		 *
		 * @param body is the turtle body to put in the cell.
		 * @return <code>true</code> if the body was successfully added,
		 * <code>false</code> otherwise
		 */
		public boolean addTurtle(TurtleBody body) {
			if (this.obstacle == null) {
				if (this.burrowedTurtles != null) {
					return this.burrowedTurtles.add(body);
				}
				if (this.turtle == null) {
					this.turtle = body;
					return true;
				}
			}
			return false;
		}

		/** Remove the given turtle body from the cell.
		 *
		 * @param body is the turtle body to remove from the cell.
		 * @return <code>true</code> if the body was successfully removed,
		 * <code>false</code> otherwise
		 */
		public boolean removeTurtle(TurtleBody body) {
			if (this.obstacle == null) {
				if (this.burrowedTurtles != null) {
					return this.burrowedTurtles.remove(body);
				}
				if (this.turtle == body) {
					this.turtle = null;
					return true;
				}
			}
			return false;
		}

		/** Create an obstacle in the cell, all turtles are implicitely burrowed.
		 *
		 * @param o
		 */
		public void createObstacle(Obstacle o) {
			this.obstacle = o;
		}

		/** Delete an obstacle in the cell.
		 */
		public void deleteObstacle() {
			this.obstacle = null;
		}

		/** Replies the obstacle if any.
		 *
		 * @return the obstacle or <code>null</code>.
		 */
		public Obstacle getObstacle() {
			return this.obstacle;
		}
		
		/** Replies the type of the ground.
		 *
		 * @return the type of the group, or <code>null</code>.
		 */
		public Serializable getGroundType() {
			return this.groundType;
		}

		/** Replies the type of the ground.
		 *
		 * @param type is the type of the group, or <code>null</code>.
		 */
		public void setGroundType(Serializable type) {
			this.groundType = type;
		}

	}

}
